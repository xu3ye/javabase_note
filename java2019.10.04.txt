1.私有属性的setXxx,getXxx方法为了private属性封装和隐藏
2.protected受保护的，类中、同一包中、子类中可用,如果权限修饰符缺省（default），访问权限为同一个包和类内部
3.同一个java文件只能有一个public类，其他类权限修饰符只能是缺省
4.new的原理就是通过调用类的构造方法，构造参数自己构造的时候可以带参数，构造器可以重载，父类的构造器子类不能继承
5.构造方法的重载有利于创建不同的对象，构造方法不需要写数据类型
6.当成员变量和形参重名时，需要添加this表明成员变量
7.this();可以调用当前类的无参的构造方法，使用这个必须得放在当前方法的首行，被调用的构造参数中也不能有this()调用
8.Set方法赋值，get方法取值
9.继承extends(拓展的意思)，子类不是父类的子集是拓展，不能直接访问私有方法!!!
10.方法的重写（@Override，方法上面会多了这个），就是对方法体的重写，其他基本不能改，子类对父类方法的重写访问权限、抛出异常不能比父类大，static要一致，方法名，参数，返回值类型要一致
11.super(),直接调用父类的构造参数，在父类只有有参构造可以使用的时候，子类必须显示构造一个来调用父类构造的有参构造，且只能放第一行
12.this访问本类中的属性，如果本类没有，就会在父类继续查找，super就直接访问父级的属性
	this访问本类的方法，super直接访问父类的方法
	this直接调用本类构造器，必须放在第一行，super调用父类构造器，必须放在子类构造器的第一行
	多级继承，调用构造器只能使用一种，因为都要第一行
13.简单对象实例化过程：（子类对象的实例化过程）
	在方法区加载.class文件（子类对象初始化时先加载父类再加载子类）
	在栈中申请空间，声明变量
	在堆中开辟空间，分配地址
	在对象的空间中，对对象的属性进行默认初始化，再进行显示初始化
	（默认初始化包括父类的属性都一起默认初始化，子类对象实例化时子类构造方法先进栈，然后显示初始化父类的属性（因为第一行调用父类的构造函数），再父类构造方法进栈，显式初始化子类的属性）
	构造函数方法进栈，进行初始化
	构造函数进栈，将堆内存中分配的地址赋值给引用变量，构造函数出栈
14.面向对象的三个基本特征：封装、继承、多态
15.多态：方法的重载和重写、对象的多态（编译时的类型和运行时的类型不一致），多态需要存在继承或者实现关系，需要有覆盖操作???
16.向上转型：父类类型的引用指向子类
	例如A是父类，B是子类，A a = new B();这就叫向上转型，子类可以看作特殊的父类
	(编译的时候a为A类型，运行的时候a为B类型)
	不能访问这个子类的变量（因为该变量编译时为父类，成员变量没有多态性），但可以访问成员方法（多态下的虚拟方法调用，动态绑定）
	子类重写了父类的方法会覆盖，但子类定义父类同样的成员变量不会覆盖，同时存在
17.instanceof操作符：  x instanceof A 意思时检验x是否为类A的对象，返回值为boolean
18.Object是基类，是所有java类的根父类
	public void test(Object object){}可以接收任何类	
19.equals()用法：a.equals(b),检验a、b是否是同一个对象，只能比较引用类型，与==相似但不相同，==是比较对象的内存地址，equals对于String是比较的值，对于其他也是比较内存的地址
	对类File、String、Date及包装类（WrapperClass）是比较其内容和类型而不考虑引用的是否是同一个对象（对象的内存地址）
    ==对于上面的那个比较的是对象（对象的地址）	
20.hashCode()用法:a.hashCode(),取得Hash码，a是一个对象
21.toString()用法:a.toString(),打印对象在堆中的地址
22.对象数据类型转化和基本数据类型转化是类似的，父类转子类可以自动转化，子类到父类需要强制转化，无继承关系转化是非法的，可以用insatnceof关键字判断是否是该类的对象
