1.jdk里面包含jre,jre里面包含jvm
2. public static void main(String[] args){
	System.out.print("hrllo");
}
3. 关键字，保留字，标识符不能包含空格(1-9,a-z,_,$)
4.文本编辑器，竖行编辑（alt+鼠标）可以统一改字符
5.包名所有字母需要小写
6.数据类型有基本数据类型（8种,整型四种，浮点型两种，字符型一种，布尔类型一种）和引用数据类型
7.byte-128~127,一个字节8比特，long类型赋值的时候要在值的后面跟上字母l,float赋值的时候要加字母f
8.String作为引用类型，在内存里只会存在一个一样的值，其他赋一样的值时会引用前一个值的内存地址
9.容量小的类型计算时会自动转化成大的计算，大的不会自动转小的，byte,char,short不会相互转化，都会首先转化成int，如两个byte相加的结果是int类型
10.A是65,a是97
11.任何基本类型的值与字符串类型（String类型，char类型会转化为ASCII计算）用+连接时都会自动转化为字符型
12.String str = 1+2+3+"a"+4+5     //输出6a45
13.强制转化，前面加上(byte)
14.字符串不能直接转化成基本类型，要通过基本类型的包装类，如integer.parselnt()字符串转整型
15.boolean不能转化为其他的数据类型
16.在使用扩展运算符时，变量参与运算会把结果强制转化为当前变量类型如short s=3;s=s+3;(错误，s+3是int)s+=3;还是short类型
17.&&，||短路运算符，&&前面不成立后面就不执行，||前面为真，后面不参与运算
18.^异或运算符，追求的是异，两边不一样才为true
19.e二进制的负数表示：补码=反码+1
	例如15的二进制=00000000 00000000 00000000 00001111（int类型 4个字节）
	    反码二进制=11111111 11111111 11111111 11110000
		所以他的补码也就是负数=反码+1
		          =11111111 11111111 11111111 11110001（-15的二进制）
20.位运算符(最高位为1代表负数，为0则为正)
	<<左移运算符，2<<3,2左移3位，就是2*2的3次方，=16
	>>右移运算符，2>>3,2右移3位，就是2*2的-3次方，=0（小数直接舍去），31>>2=7,-32>>2=8，-2>>3=1(因为最高位右移补1)
	>>>无符号右移运算符（没有无符号左边）：正数和上面一致，不同的是负数右移的时候不管首位是0还是1最高位补0
	&就是把数值用2进制比较，两个为1就是1，其他就是0，例如1011，0110，结果0010
	|就是把数值改为2进制，除了0，0等于0，其他都是1
	^不同的为1，相同的为0
	~取反运算，1变0，0变1
21.三元运算符，判断三个数中的最大数，m=2,n=1,k=0
	m>n?(m>k?m:k):(n>k?n:k)
22.程序流程控制
	顺序结构：从上到下逐行的执行
	分支结构：if else,switch两种
	循环结构：for,while,do while,foreach
	